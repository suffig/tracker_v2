// Simple Supabase client implementation
window.supabase = window.supabase || {};

// Simple HTTP client
class SupabaseClient {
  constructor(supabaseUrl, supabaseKey, options = {}) {
    this.supabaseUrl = supabaseUrl;
    this.supabaseKey = supabaseKey;
    this.options = options;
    this.authCallbacks = [];
    this.currentSession = null;
  }

  // Auth methods
  get auth() {
    const self = this;
    return {
      getSession: async () => {
        try {
          const stored = localStorage.getItem('supabase.auth.token');
          if (stored) {
            const session = JSON.parse(stored);
            if (session.expires_at && session.expires_at > Date.now() / 1000) {
              self.currentSession = session;
              return { data: { session }, error: null };
            } else {
              localStorage.removeItem('supabase.auth.token');
            }
          }
        } catch (e) {
          localStorage.removeItem('supabase.auth.token');
        }
        return { data: { session: null }, error: null };
      },

      onAuthStateChange: (callback) => {
        self.authCallbacks.push(callback);
        // Initial callback
        setTimeout(() => {
          callback(self.currentSession ? 'SIGNED_IN' : 'SIGNED_OUT', self.currentSession);
        }, 100);
        
        return { 
          data: { 
            subscription: { 
              unsubscribe: () => {
                self.authCallbacks = self.authCallbacks.filter(cb => cb !== callback);
              } 
            } 
          } 
        };
      },

      signInWithPassword: async ({ email, password }) => {
        try {
          const response = await fetch(`${self.supabaseUrl}/auth/v1/token?grant_type=password`, {
            method: 'POST',
            headers: {
              'apikey': self.supabaseKey,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, password })
          });

          const data = await response.json();
          
          if (response.ok && data.access_token) {
            const session = {
              access_token: data.access_token,
              refresh_token: data.refresh_token,
              expires_at: data.expires_at,
              expires_in: data.expires_in,
              token_type: data.token_type,
              user: data.user
            };
            
            self.currentSession = session;
            localStorage.setItem('supabase.auth.token', JSON.stringify(session));
            
            // Notify listeners
            self.authCallbacks.forEach(callback => {
              setTimeout(() => callback('SIGNED_IN', session), 50);
            });
            
            return { data: { user: data.user, session }, error: null };
          } else {
            return { data: { user: null, session: null }, error: new Error(data.error_description || 'Login failed') };
          }
        } catch (error) {
          return { data: { user: null, session: null }, error };
        }
      },

      signUp: async ({ email, password }) => {
        try {
          const response = await fetch(`${self.supabaseUrl}/auth/v1/signup`, {
            method: 'POST',
            headers: {
              'apikey': self.supabaseKey,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ email, password })
          });

          const data = await response.json();
          
          if (response.ok) {
            return { data: { user: data.user, session: data.session }, error: null };
          } else {
            return { data: { user: null, session: null }, error: new Error(data.error_description || 'Signup failed') };
          }
        } catch (error) {
          return { data: { user: null, session: null }, error };
        }
      },

      signOut: async () => {
        try {
          if (self.currentSession) {
            await fetch(`${self.supabaseUrl}/auth/v1/logout`, {
              method: 'POST',
              headers: {
                'apikey': self.supabaseKey,
                'Authorization': `Bearer ${self.currentSession.access_token}`
              }
            });
          }
        } catch (e) {
          // Ignore errors on logout
        }

        self.currentSession = null;
        localStorage.removeItem('supabase.auth.token');
        
        // Notify listeners
        self.authCallbacks.forEach(callback => {
          setTimeout(() => callback('SIGNED_OUT', null), 50);
        });
        
        return { error: null };
      }
    };
  }

  // Database methods
  from(table) {
    const self = this;
    let query = '';
    let filters = [];
    let ordering = '';
    let limiting = '';

    const queryBuilder = {
      select: (columns = '*') => {
        query = columns;
        return queryBuilder;
      },

      eq: (column, value) => {
        filters.push(`${column}=eq.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      neq: (column, value) => {
        filters.push(`${column}=neq.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      gt: (column, value) => {
        filters.push(`${column}=gt.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      gte: (column, value) => {
        filters.push(`${column}=gte.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      lt: (column, value) => {
        filters.push(`${column}=lt.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      lte: (column, value) => {
        filters.push(`${column}=lte.${encodeURIComponent(value)}`);
        return queryBuilder;
      },

      like: (column, pattern) => {
        filters.push(`${column}=like.${encodeURIComponent(pattern)}`);
        return queryBuilder;
      },

      in: (column, values) => {
        filters.push(`${column}=in.(${values.map(v => encodeURIComponent(v)).join(',')})`);
        return queryBuilder;
      },

      order: (column, options = {}) => {
        ordering = `order=${column}.${options.ascending === false ? 'desc' : 'asc'}`;
        return queryBuilder;
      },

      limit: (count) => {
        limiting = `limit=${count}`;
        return queryBuilder;
      },

      range: (start, end) => {
        limiting = `offset=${start}&limit=${end - start + 1}`;
        return queryBuilder;
      },

      single: async () => {
        const result = await queryBuilder.executeQuery();
        if (result.error) return result;
        return { data: result.data?.[0] || null, error: null };
      },

      maybeSingle: async () => {
        const result = await queryBuilder.executeQuery();
        if (result.error) return result;
        return { data: result.data?.[0] || null, error: null };
      },

      executeQuery: async () => {
        try {
          const params = new URLSearchParams();
          if (query) params.append('select', query);
          if (filters.length) filters.forEach(f => {
            const [key, value] = f.split('=');
            params.append(key, value);
          });
          if (ordering) params.append('order', ordering.split('=')[1]);
          if (limiting) {
            const limitParts = limiting.split('&');
            limitParts.forEach(part => {
              const [key, value] = part.split('=');
              params.append(key, value);
            });
          }

          const headers = {
            'apikey': self.supabaseKey,
            'Accept': 'application/json'
          };

          if (self.currentSession?.access_token) {
            headers['Authorization'] = `Bearer ${self.currentSession.access_token}`;
          }

          const response = await fetch(`${self.supabaseUrl}/rest/v1/${table}?${params}`, {
            headers
          });

          if (response.ok) {
            const data = await response.json();
            return { data, error: null };
          } else {
            const error = await response.text();
            return { data: null, error: new Error(error) };
          }
        } catch (error) {
          return { data: null, error };
        }
      },

      insert: (data) => {
        return {
          select: (columns = '*') => {
            return {
              single: async () => {
                try {
                  const headers = {
                    'apikey': self.supabaseKey,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation'
                  };

                  if (self.currentSession?.access_token) {
                    headers['Authorization'] = `Bearer ${self.currentSession.access_token}`;
                  }

                  const response = await fetch(`${self.supabaseUrl}/rest/v1/${table}`, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify(data)
                  });

                  if (response.ok) {
                    const result = await response.json();
                    return { data: Array.isArray(result) ? result[0] : result, error: null };
                  } else {
                    const error = await response.text();
                    return { data: null, error: new Error(error) };
                  }
                } catch (error) {
                  return { data: null, error };
                }
              }
            };
          }
        };
      },

      update: (data) => {
        return {
          eq: (column, value) => {
            return {
              select: async () => {
                try {
                  const headers = {
                    'apikey': self.supabaseKey,
                    'Content-Type': 'application/json',
                    'Prefer': 'return=representation'
                  };

                  if (self.currentSession?.access_token) {
                    headers['Authorization'] = `Bearer ${self.currentSession.access_token}`;
                  }

                  const response = await fetch(`${self.supabaseUrl}/rest/v1/${table}?${column}=eq.${encodeURIComponent(value)}`, {
                    method: 'PATCH',
                    headers,
                    body: JSON.stringify(data)
                  });

                  if (response.ok) {
                    const result = await response.json();
                    return { data: result, error: null };
                  } else {
                    const error = await response.text();
                    return { data: null, error: new Error(error) };
                  }
                } catch (error) {
                  return { data: null, error };
                }
              }
            };
          }
        };
      },

      delete: () => {
        return {
          eq: async (column, value) => {
            try {
              const headers = {
                'apikey': self.supabaseKey,
                'Prefer': 'return=representation'
              };

              if (self.currentSession?.access_token) {
                headers['Authorization'] = `Bearer ${self.currentSession.access_token}`;
              }

              const response = await fetch(`${self.supabaseUrl}/rest/v1/${table}?${column}=eq.${encodeURIComponent(value)}`, {
                method: 'DELETE',
                headers
              });

              if (response.ok) {
                const result = await response.json();
                return { data: result, error: null };
              } else {
                const error = await response.text();
                return { data: null, error: new Error(error) };
              }
            } catch (error) {
              return { data: null, error };
            }
          }
        };
      },

      // Make queryBuilder thenable (awaitable)
      then: (resolve, reject) => {
        queryBuilder.executeQuery().then(resolve, reject);
      },

      catch: (reject) => {
        queryBuilder.executeQuery().catch(reject);
      },

      finally: (callback) => {
        queryBuilder.executeQuery().finally(callback);
      }
    };

    return queryBuilder;
  }

  // Realtime methods (simplified)
  channel(channelName = 'default') {
    console.warn('Realtime functionality is simplified in this minimal client');
    
    return {
      on: (event, config, callback) => {
        console.log(`Subscribed to ${event} on ${config?.table || 'unknown'}`);
        return this;
      },
      subscribe: (statusCallback) => {
        if (statusCallback) {
          setTimeout(() => statusCallback('SUBSCRIBED'), 100);
        }
        return this;
      },
      unsubscribe: () => {
        return Promise.resolve({ error: null });
      }
    };
  }

  removeChannel(channel) {
    if (channel && typeof channel.unsubscribe === 'function') {
      return channel.unsubscribe();
    }
    return Promise.resolve({ error: null });
  }
}

// Export the createClient function
function createClient(supabaseUrl, supabaseKey, options) {
  return new SupabaseClient(supabaseUrl, supabaseKey, options);
}

window.supabase.createClient = createClient;